---
title: Request signature
sidebar_position: 3
---

Before sending a response to a request, your service must check the validity of
the signature `sign` and the creation time `time`.

### `time`

Equals the number of seconds since UnixEpoch (January 1 1970 00:00:00 GMT).
If the time from the creation of the request to its verification is more than 10
seconds, the request is considered invalid. The response with `errorCode: 4` 
must be returned.

### `sign`

```python
import base64
import hashlib
import json

# Example request data
data = {
    "type": "payment",
    "token2": "abc",
    "time": 485172195,
    "Info": '[{"EventName":"Transaction A","DateStart":1538609400,"Category":"Category Name"}]',
    "amount": "10",
}

# Secret key
SECRET = "SECRET"

# Convert data to JSON and concatenate with SECRET
serialized_data = json.dumps(data, separators=(",", ":"))
data_to_sign = serialized_data + SECRET

# Calculate MD5 hash and encode in Base64
md5_hash = hashlib.md5(data_to_sign.encode('utf-8')).digest()
sign = base64.b64encode(md5_hash).decode('utf-8')

print("Signature:", sign)
```

This example demonstrates how to calculate the `sign` field. The signature must be validated by the recipient's server to confirm the integrity and authenticity of the request.

## Checking the time and signature of the request

On the side of your service, the following mechanism must be implemented:

```python
import base64
import hashlib
import json

# Example request data (received from client)
received_data = {
    "type": "payment",
    "token2": "abc",
    "time": 485172195,
    "Info": '[{"EventName":"Transaction A","DateStart":1538609400,"Category":"Category Name"}]',
    "amount": "10",
    "sign": "EXPECTED_SIGNATURE",  # Replace with the signature received in the request
}

# Secret key
SECRET = "SECRET"

# Extract and remove the signature from the request
received_sign = received_data.pop("sign")

# Serialize data and append SECRET
serialized_data = json.dumps(received_data, separators=(",", ":"))
data_to_sign = serialized_data + SECRET

# Recalculate the signature
md5_hash = hashlib.md5(data_to_sign.encode('utf-8')).digest()
calculated_sign = base64.b64encode(md5_hash).decode('utf-8')

# Validate the signature
if calculated_sign == received_sign:
    print("Signature is valid.")
else:
    print("Signature is invalid.")
```

The process ensures the integrity and authenticity of the request by verifying the `sign` field. If the signature matches, the request is valid. Otherwise, it should be rejected.
